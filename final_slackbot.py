# -*- coding: utf-8 -*-
"""final_slackbot.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1m79W_6Ej37Gfb_hSOzXtBb4UYpchzN_u
"""

!pip install slackclient
!pip install python-dotenv
!pip install yfinance --upgrade --no-cache-dir
!pip install slack_sdk

# Dependency download process explained here: https://www.youtube.com/watch?v=vf1m1ogKYrg

import yfinance as yf
import pandas as pd
import slack
import time
import numpy as np
from datetime import datetime, date, timedelta

SLACK_TOKEN="xoxb-1604370689942-2811270161506-Qu44i5WJpyN9HAVWuU3wmVFj"

'''
Written by Siddharth Cherukupalli and Urjoshi Nahid
'''

# Apex Google Sheets Setup

sheet_id = "1P9p4f0TTpNg-wpwSySDY238Za-lpvukTFbiO9ozhYPA"
sheet_name = "Holdings"
holdingsUrl = f"https://docs.google.com/spreadsheets/d/{sheet_id}/gviz/tq?tqx=out:csv&sheet={sheet_name}"
holdingsSheet = pd.read_csv(holdingsUrl)
display(holdingsSheet)

grossReturnSheet_name = "Gross_Returns"
grossReturnUrl = f"https://docs.google.com/spreadsheets/d/{sheet_id}/gviz/tq?tqx=out:csv&sheet={grossReturnSheet_name}"
grossReturnSheet = pd.read_csv(grossReturnUrl)

NUM_OF_PORTFOLIO_TICKERS = 0
idx = 0
# Fundamental analysts have been told to put STOP in the google sheet after all stocks for our program knows when to stop
while (holdingsSheet['Holdings '][idx] != "STOP"):  
  curr_val = holdingsSheet['Holdings '][idx]
  NUM_OF_PORTFOLIO_TICKERS += 1
  idx+=1

# Initialize the global variables that hold the Tickers in our portfolio and the major stock indices 
# we would like to display in the final slackbot for comparison
TICKERS = []
for num in range(NUM_OF_PORTFOLIO_TICKERS):
  TICKERS.append(holdingsSheet['Holdings '][num])

indices = ["^GSPC", "^RUT", "^DJI"]
indicesNames = ["S&P 500", "Russell 2000", "Dow Jones Industrial"]

# Downloading Ticker Data 
NOW = datetime.now()
if (NOW.hour > 0 and NOW.hour<5):
  today = date.today() -timedelta(days=1)
else: 
  today = date.today()

todayDateFormatted = today.strftime("%Y-%m-%d")
# Returns a table with ticker and their corresponding current prices 
currentData = yf.download(TICKERS,todayDateFormatted)['Adj Close']

oneDayAgoDate = today - timedelta(days=1)
oneDayAgoDateFormatted = oneDayAgoDate.strftime("%Y-%m-%d")
#returns a table with ticker and the first row is the closing price from yesterday
oneDayAgoOldData = yf.download(TICKERS,oneDayAgoDateFormatted)['Adj Close']


monthAgoDate = today - timedelta(days=30)
monthDateFormatted = monthAgoDate.strftime("%Y-%m-%d")
# Returns a table with ticker and the first row is their corresponding month ago prices 
monthOldData = yf.download(TICKERS,monthDateFormatted)['Adj Close']

yearAgoDate = today - timedelta(days=365)
yearDateFormatted = yearAgoDate.strftime("%Y-%m-%d")
# Returns a table with ticker and the first row is their corresponding year ago prices 
yearOldData = yf.download(TICKERS,yearDateFormatted)['Adj Close']

# Download indices data 

currentIndicesData = yf.download(indices,todayDateFormatted)['Adj Close']
yesterdayIndicesData = yf.download(indices,oneDayAgoDateFormatted)['Adj Close']

# portfolioStats function goes through a Google Sheet and appends each holding and their P/L to a string called "Table". Also appends the 
# portfolio's total gross returns. Function returns the String "table"

def portfolioStats():
  print(NUM_OF_PORTFOLIO_TICKERS)
  # Original Google Sheet URL: https://docs.google.com/spreadsheets/d/1P9p4f0TTpNg-wpwSySDY238Za-lpvukTFbiO9ozhYPA/edit?usp=sharing
  table = "----------Apex Portfolio Statistics----------\n";
  for num in range(NUM_OF_PORTFOLIO_TICKERS):
    table += str(holdingsSheet['Holdings '][num]) + " P/L: " + str(holdingsSheet['P/L'][num]) + "\n"
  table += "Portfolio Gross Return: " + grossReturnSheet['Gross Returns'][0] + "\n\n"
  return table
portfolioStats()

# Ledger Google sheets setup 
ledgerSheet_id = "19jvkeFbXugVMTmWj4zczjRPK6t-tksnBOHe63emRqCI"
ledgerSheet_name = "LedgerOfOrders"
ledgerURL = f"https://docs.google.com/spreadsheets/d/{ledgerSheet_id}/gviz/tq?tqx=out:csv&sheet={ledgerSheet_name}"
ledgerSheet = pd.read_csv(ledgerURL)

# Original Google Sheet URL: https://docs.google.com/spreadsheets/d/19jvkeFbXugVMTmWj4zczjRPK6t-tksnBOHe63emRqCI/edit?usp=sharing

def calculateValue(dataSheet):
  marketPrices = {}
  for ticker in TICKERS:
    currentPrice = dataSheet[ticker][0]
    marketPrices[ticker]=currentPrice
  return (marketPrices)

# Takes in previous market values and returns an integer that describes the return over time to current market value 
def returnOverTime(oldMarketValue, currentMarketValue):
  return ((currentMarketValue-oldMarketValue) * 100 / (oldMarketValue))

# Returns a string that consists of each ticker and their 1 day change and current price 

def getPrices(tickers, indices):
  finalOutputString = "--------------------Major Indices-------------------- \n" 
  count = 0 
  for index in indices:
    closePrice = yesterdayIndicesData[index][0]
    currentPrice = currentIndicesData[index][0]
    dayOverDayChange = returnOverTime(closePrice, currentPrice)
    # formatting dayOverDayChange to 2 decimal places
    twoDecimalsStrFormat = "{:.2f}".format(dayOverDayChange) + "%"
    currentIndicesName = indicesNames[count]
    finalOutputString += currentIndicesName + " Current Price: $" + str(currentPrice)
    finalOutputString += " || 1d change: " + twoDecimalsStrFormat + "\n"
    count = count + 1 

  finalOutputString += "\n--------------------Current Holdings-------------------- \n" 
  currentMarketPrices = calculateValue(currentData)
  for key, value in currentMarketPrices.items():
    value = str("{:.2f}".format(value))
    finalOutputString+= key + " Current Price: $" + value + "\n" 
 
  return finalOutputString

#Day over Day Price Changes
# This function returns a string that returns every stock and their day over day changes. The changes are calculated using the previous 
# close price and the close price from the previous day

def getChanges(TICKERS):
  result = "--------------------Day over Day Changes-------------------- \n"
  for tick in TICKERS:
    currentPrice = currentData[tick][0]
    closePrice = oneDayAgoOldData[tick][0]
    percentage = (currentPrice/closePrice -1) * 100
    strFormat = "{:.2f}".format(percentage) + "%"
    result += tick + " 1d change: " + strFormat + "\n"
  return result

# returns a dictionary with the keys being tickers and the corresponding values being their closing price from one year ago
def calculateYearOldValue(holdingsSheet):
  yearOldPrices = {}
  for ticker in TICKERS:
    yearOldPrice = yearOldData[ticker][0]
    if np.isnan(yearOldPrice):
      tickerName = yf.Ticker(ticker)
      yearOldDataTable = tickerName.history(period="max")
      yearOldPrice = yearOldDataTable['Close'][0]
    yearOldPrices[ticker]=yearOldPrice
  return (yearOldPrices)

# This function returns a map where the key is the ticker name and the value is the quantity of stocks held. 
# Value is changed on whether the stock is bought or sold 
def calculateCurrentHoldingQuantities():
  TOTAL_DATES=len(ledgerSheet.index)
  
  apexHierarchy = {} 
  for num in range(TOTAL_DATES):
    tickerName = ledgerSheet['Ticker'][num]
    tickerQuant = ledgerSheet['Quantity'][num]
    buyOrSell= ledgerSheet['Action'][num]
    
    if tickerName in apexHierarchy:
      if buyOrSell=="Buy":
        apexHierarchy[tickerName] = apexHierarchy[tickerName] + tickerQuant
      if buyOrSell=="Sell":
        apexHierarchy[tickerName] = apexHierarchy[tickerName] - tickerQuant
    else: #initialize empty key if it has no value
      if buyOrSell=="Buy":
        apexHierarchy[tickerName] = tickerQuant

  return apexHierarchy

# This function finds a portfolio's market value by multiplying each stocks price by its quantity and then summing them all up. 
# An integer is returned  
def calculatePortfolioMarketValue(currentMarketPrices, stocksQuantMap):
  priceSum = 0
  for key in currentMarketPrices: 
    if (key in stocksQuantMap):
      priceSum = priceSum + currentMarketPrices[key] * stocksQuantMap[key]
  return (priceSum)

# This function returns a string that contains the portfolio's monthly and yearly return
def getReturns():
  marketPrices = calculateValue(currentData)
  monthOldPrices = calculateValue(monthOldData)
  yearOldPrices = calculateYearOldValue(yearOldData)
  stockQuantMap = calculateCurrentHoldingQuantities()
  currentPortfolioMarketValue= calculatePortfolioMarketValue(marketPrices, stockQuantMap)
  monthAgoPortfolioMarketValue= calculatePortfolioMarketValue(monthOldPrices, stockQuantMap)
  yearAgoPortfolioMarketValue = calculatePortfolioMarketValue(yearOldPrices, stockQuantMap)
  monthReturn = "{:.2f}".format(returnOverTime(monthAgoPortfolioMarketValue,currentPortfolioMarketValue))
  yearReturn = "{:.2f}".format(returnOverTime(yearAgoPortfolioMarketValue,currentPortfolioMarketValue))
  finalOutputString = "--------------------Current Returns----------------- \n"
  finalOutputString+= "Monthly Return: " + str(monthReturn) + "%\n"
  finalOutputString+= "Yearly Return: " + str(yearReturn) + "%\n"
  
  return finalOutputString

MAX_STORIES = 3;
SECONDS_IN_A_MINUTE=60
MINUTES_IN_A_HOUR=60
SECONDS_IN_A_HOUR=SECONDS_IN_A_MINUTE * MINUTES_IN_A_HOUR
HOURS_IN_A_DAY=24
SECONDS_IN_A_DAY=SECONDS_IN_A_HOUR * HOURS_IN_A_DAY
def getNews(tickers):
  res = "--------------------Current News-------------------- \n"
  for tick in tickers:
    storyCount = 1
    ticker = yf.Ticker(tick)
    news = ticker.news
    res += "-----" + ticker.ticker + " News----- \n"
    for elem in news:
      link = elem['link']
      publisher = elem['publisher']
      title = elem['title']
      timeDiff = time.time() - elem['providerPublishTime']
      if (storyCount <= MAX_STORIES):
        if (timeDiff <= (SECONDS_IN_A_DAY)): 
         res += "\n" + publisher + "\n" + title + "\n" + link + "\n\n"
         storyCount += 1 
    
  return res

def run_lambda(event, context):
  message = "<!channel> \n" # this creates the "@channel" notification in the final slack message
  message += portfolioStats()
  message += getReturns() + "\n" 
  message += getPrices(TICKERS, indices) + "\n" 
  message += getChanges(TICKERS) + "\n" 
  message += getNews(TICKERS)
  
  client = slack.WebClient(token=SLACK_TOKEN)
  client.chat_postMessage(channel = "#daily-slackbot", text=message)

  return message

